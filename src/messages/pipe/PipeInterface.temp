/**
 * @author      : theo (theo@$HOSTNAME)
 * @file        : PipeInterface
 * @created     : Saturday Sep 14, 2019 12:46:54 MDT
 */

#include "core/messages/pipe/PipeInterface.hpp"

#include <memory>
#include <future>
#include <string>

PipeInterface::PipeInterface() {}

bool PipeInterface::create_pub_sub_endpoint(const std::string &id,
                                            const std::string &frontend,
                                            const std::string &backend,
                                            const bool start_on_creation) {

  
  auto found = proxies.proxies.find(id);
  if(found != proxies.proxies.end()) {
    LOG_ERROR("Invalid request to build a pub sub proxy on id %s, already exists", id.c_str());
    return false;
  }

  proxy_t proxy;
  std::future<void> futureObj = proxy.exit_signal.get_future();
  proxy.proxy = std::make_unique<ProxyInterface>  


  proxy.exit_signal = 
    	// Create a std::promise object
	std::promise<void> exitSignal;

	//Fetch std::future object associated with promise
	std::future<void> futureObj = exitSignal.get_future();

	// Starting Thread & move the future object in lambda function by reference
	std::thread th(&threadFunction, std::move(futureObj));

	//Wait for 10 sec
	std::this_thread::sleep_for(std::chrono::seconds(10));

	std::cout << "Asking Thread to Stop" << std::endl;

	//Set the value in promise
	exitSignal.set_value();

	//Wait for thread to join
	th.join();

	std::cout << "Exiting Main Function" << std::endl;
	return 0;
  

    
}

bool PipeInterface::create_req_rep_endpoint(const std::string &id,
                                            const std::string &frontend,
                                            const std::string &backend,
                                            const bool start_on_creation) {

}

bool PipeInterface::stop(const std::string& id);
bool PipeInterface::kill(const std::string& id);
int PipeInterface::signal(const std::string& id, const int32_t signal_val);
bool PipeInterface::register_signal(const std::string& id, const int32_t signal_val, std::function<int(void)>);
bool PipeInterface::set_filter(const std::string& id, std::unique_ptr<FilterInterface> filter);
